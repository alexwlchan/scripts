#!/usr/bin/env python3
"""
This is a script for lightweight dependency tracking.

This tries to add a comment to any imports I have in a file, telling me
what version I had installed when I wrote a script, e.g.

    import os
    import humanize

becomes

    import os
    import humanize  # humanize==4.4.0

I use this for a lot of scripts in this repo, when:

-   I don't want to set up a requirements.txt file for each script
    (and it wouldn't be accurate anyway)

-   I might go a long time between writing and running a script, and
    a third-party library might upgrade in the meantime -- and then it's
    useful to know what I originally used if the script breaks

-   I don't want to retest every script every time I upgrade a library.

"""

import os
import re
import shutil
import subprocess
import sys


def get_freeze_string(library_name):
    if library_name in {"json", "os", "re", "subprocess", "sys", "tempfile"}:
        return None

    try:
        pip_output = subprocess.check_output(
            f"pip freeze | grep {library_name}", shell=True
        )
    except subprocess.CalledProcessError:
        return None
    else:
        return pip_output.decode("utf8").strip()


if __name__ == "__main__":
    try:
        infile = sys.argv[1]
    except IndexError:
        sys.exit(f"Usage: {__file__} <PATH>")

    lines = []

    for line in open(infile):
        m1 = re.match(r"^import (?P<library_name>[a-zA-Z0-9]+)\n$", line)
        m2 = re.match(r"^from (?P<library_name>[a-zA-Z0-9]+) import [^#]*$", line)

        if m1 is None and m2 is None:
            lines.append(line)
            continue

        if m1 is not None:
            library_name = m1.group("library_name")
        elif m2 is not None:
            library_name = m2.group("library_name")

        freeze = get_freeze_string(library_name)

        if freeze:
            lines.append(f"{line.rstrip()}  # {freeze}\n")
        else:
            lines.append(line)

    # Note: the original implementation wrote the modified script to
    # a temporary file first, then os.rename-d that over the original.
    #
    # This is annoying because the new file wouldn't have the same
    # file permissions -- in particular whether the file is executable.
    # (In fact, the backup file would become executable and enter the PATH!)
    #
    # The easiest one percent of the missions is just to override the
    # contents of the original file.
    shutil.copyfile(infile, infile + ".pip_freeze.bak")

    with open(infile, "w") as outfile:
        outfile.write("".join(lines))
